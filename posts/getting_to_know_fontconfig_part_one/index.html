<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>深入理解 Linux fontconfig 第一部分：有关工作流的假设 | Marguerite Su: Golang/Ruby Programmer, openSUSE Member</title>
<meta name="keywords" content="">
<meta name="description" content="这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。
偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。
先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。
但是呢，实际上这种方法在现实中不怎么灵。
&lt;match target=&quot;scan&quot;&gt; &lt;test name=&quot;family&quot;&gt; &lt;string&gt;Noto Sans CJK SC&lt;/string&gt; &lt;/test&gt; &lt;edit name=&quot;charset&quot; mode=&quot;assign&quot;&gt; &lt;minus&gt; &lt;name&gt;charset&lt;/name&gt; &lt;charset&gt; &lt;int&gt;0x2122&lt;/int&gt; &lt;/charset&gt; &lt;/minus&gt; &lt;/edit&gt; &lt;/match&gt; 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset 的操作了，但是在 Chromium 浏览器中测试是这样的：">
<meta name="author" content="">
<link rel="canonical" href="https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.bc1149f4a72aa4858d3a9f71462f75e5884ffe8073ea9d6d5761d5663d651e20.css" integrity="sha256-vBFJ9KcqpIWNOp9xRi915YhP/oBz6p1tV2HVZj1lHiA=" rel="preload stylesheet" as="style">
<script defer crossorigin="anonymous" src="/assets/js/highlight.f413e19d0714851f6474e7ee9632408e58ac146fbdbe62747134bea2fa3415e0.js" integrity="sha256-9BPhnQcUhR9kdOfuljJAjlisFG&#43;9vmJ0cTS&#43;ovo0FeA="
    onload="hljs.initHighlightingOnLoad();"></script>
<link rel="icon" href="https://marguerite.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://marguerite.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://marguerite.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://marguerite.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://marguerite.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --hljs-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:title" content="深入理解 Linux fontconfig 第一部分：有关工作流的假设" />
<meta property="og:description" content="这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。
偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。
先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。
但是呢，实际上这种方法在现实中不怎么灵。
&lt;match target=&quot;scan&quot;&gt; &lt;test name=&quot;family&quot;&gt; &lt;string&gt;Noto Sans CJK SC&lt;/string&gt; &lt;/test&gt; &lt;edit name=&quot;charset&quot; mode=&quot;assign&quot;&gt; &lt;minus&gt; &lt;name&gt;charset&lt;/name&gt; &lt;charset&gt; &lt;int&gt;0x2122&lt;/int&gt; &lt;/charset&gt; &lt;/minus&gt; &lt;/edit&gt; &lt;/match&gt; 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset 的操作了，但是在 Chromium 浏览器中测试是这样的：" />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2022-11-25T12:13:29+08:00" />
<meta property="article:modified_time" content="2022-11-25T12:13:29+08:00" />

<meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="深入理解 Linux fontconfig 第一部分：有关工作流的假设"/>
<meta name="twitter:description" content="这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。
偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。
先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。
但是呢，实际上这种方法在现实中不怎么灵。
&lt;match target=&quot;scan&quot;&gt; &lt;test name=&quot;family&quot;&gt; &lt;string&gt;Noto Sans CJK SC&lt;/string&gt; &lt;/test&gt; &lt;edit name=&quot;charset&quot; mode=&quot;assign&quot;&gt; &lt;minus&gt; &lt;name&gt;charset&lt;/name&gt; &lt;charset&gt; &lt;int&gt;0x2122&lt;/int&gt; &lt;/charset&gt; &lt;/minus&gt; &lt;/edit&gt; &lt;/match&gt; 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset 的操作了，但是在 Chromium 浏览器中测试是这样的："/>


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "Posts",
      "item": "https://marguerite.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  3 ,
      "name": "深入理解 Linux fontconfig 第一部分：有关工作流的假设",
      "item": "https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入理解 Linux fontconfig 第一部分：有关工作流的假设",
  "name": "深入理解 Linux fontconfig 第一部分：有关工作流的假设",
  "description": "这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。\n偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。\n先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。\n但是呢，实际上这种方法在现实中不怎么灵。\n\u0026lt;match target=\u0026quot;scan\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;charset\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;minus\u0026gt; \u0026lt;name\u0026gt;charset\u0026lt;/name\u0026gt; \u0026lt;charset\u0026gt; \u0026lt;int\u0026gt;0x2122\u0026lt;/int\u0026gt; \u0026lt;/charset\u0026gt; \u0026lt;/minus\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset 的操作了，但是在 Chromium 浏览器中测试是这样的：",
  "keywords": [
    
  ],
  "articleBody": "这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。\n偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。\n先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。\n但是呢，实际上这种方法在现实中不怎么灵。\nNoto Sans CJK SC charset 0x2122 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset 的操作了，但是在 Chromium 浏览器中测试是这样的：\n™ 你好 那个 TM 码点依然使用 Noto Sans CJK SC 显示。纳尼！TM 不是已经被屏蔽了嘛？\n简单朴素但不一定对的 fontconfig 工作流假设 以上 charset minus 的方法源于我（可能也是大多数人）的一个朴素假设：\nfontconfig 的工作流程是先取系统上安装的全部字体，生成一个无序列表，然后通过 pattern match 调整这个列表，最后使用 font match 调整最终列表中字体的属性，返回给调用它的程序使用。\n换句话说，我们假设的是，程序调用 fontconfig 是调用一个完整的工作流，最终返回给程序的字体中没有这个被减掉的 charset。返回的字体可以是 fontconfig 的缓存，也可以是真实的字体但同时返回的字体 charset 属性中没有这个被减掉的 charset，导致程序通过通过 charset 匹配 text 的阶段会失败，从而不去使用这个字体去显示这个字符。\n当然了，fontconfig 毕竟不是 fontforge 这样的字体编辑程序，真实的在硬盘上的字体文件里这个字符肯定还是存在的。也许是 fontconfig 在缓存 binary data 的时候就去掉了这个 charset，也许只是在字体属性中去掉了。\n但很可惜，这个假设通过我的 debug 发现它，对也不对。对的地方是在 fontconfig 自己的 utilities 比如 fc-match, fc-list 里，它是对的。错的地方是在别的程序里，调用方式的不同导致这个工作流很可能被掐头去尾取中间了。也就是说别的程序可能只是使用了 fontconfig 的 pattern match 阶段，得到字体就万事大吉了。后面的 font match 阶段可能根本就没有用（这个存疑，目前还没有 debug 到这里）。\n可能是正确的获取字体的方式（以 fc-list 为例） 我们前面文章已经说过了，测试 charset minus 方法是否成功的方式有一种是使用：\nfc-list \"Noto Sans CJK SC\" :charset=0x2122 而我还看到过一种方式，就是依云的 使用 fontconfig 进行字体查询。\n首先我复制了一份 fc-list.c 的代码（不到没有办法肯定不能 runtime 改系统的 fontconfig 啊），改了以下地方：\n+ printf(\"%d\\n\", i); + printf(\"%d\\n\", argc); + printf(\"%s\\n\", argv[1]); + printf(\"%s\\n\", argv[2]); if (argv[i]) { pat = FcNameParse ((FcChar8 *) argv[i]); if (!pat) { fprintf (stderr, _(\"Unable to parse the pattern\\n\")); return 1; } while (argv[++i]) { if (!os) { os = FcObjectSetCreate (); FcObjectSetAdd (os, argv[i]); } } } 首先我需要知道 fc-lsit 把我的 Noto Sans CJK SC 和 :charset=0x2122 都识别成什么了。结果是把字体名字识别成 pattern：\npat = FcNameParse((FcChar8 *) argv[i]); 把 :charset=0x2122 识别成了（这里说以下这个冒号就是个语法糖，表示“全部字体”，相当于 : charset=0x2122，也可以有别的写法比如 : family lang）：\nos = FcObjectSetCreate(); 然后后面的：\nfs = FcFontList (0, pat, os); 得到 FontSet。\nFcFontList 会内部调用 FcFontSetList (config, sets, nsets, p, os);，这里的 config 是 config = FcConfigReference (config); 但很明显我们传给它的 config 是 0 所以没什么用。sets 和 nsets是 FcFontList 里定义的并传过来的，我们传过来的 pattern 和 objectset 在这里起到的是筛选的作用，如果 sets-\u003efonts[n] 不满足 pattern，loop 就会 continue, 相当于是丢弃了这个 font。\n这个 FcFontSetList 函数下次使用 os 是在 if (!FcListAppend (\u0026table, s-\u003efonts[f], os, lang)) (如果没有 os，FcFontSetList 在前面会创建一个空的 os)。这里的 \u0026table 是 FcListHashTable, 最终是通过 FcFontSetAdd 把 table 里的 font 加到 ret = FcFontSetCreate(); 这个新建的 FontSet 中并返回这个新建的 ret，作为 FcFontList 返回的 FontSet。\n所以这里 FcListAppend 的作用是通过 objectsets 和 lang 去判断这个字体可不可以加入到最终的 FontSet。后面再深入的代码我们就不继续看了。下面是结论：\n通过 pattern 和 objectset 一起得到的 FontSet 会得到应用了 charset minus 的结果。\n说人话就是显式地使用 :charset=0x2122 去要求 charset 就会得到精确的减除 charset 后的字体。\n那么隐含式的调用呢？我们来看依云的代码（我做了截取）：\n他这里的 os 相当于是新建的空 ObjectSet，所以他最终的 FontSet 里面包含了 “Noto Sans CJK SC”。下面的 FcPatternGetCharSet 取的是真实字体的 Charset，也包含了 TM 字符。这在 FcCharSetHasChar 也得到了验证。\n换句话说，如果想要取得 fontconfig 的 font match 结果后的字体，这个程序要改为使用 objectset，即：\n以上对 fc-list.c 和依云的 demo 的分析验证了上面假设中最没有用一部分，即：真实的在硬盘上的字体文件里这个字符肯定还是存在的。同时也说明了另一个事情：FcPatternGetCharset获取字体 charsets 是严格依赖喂给它的 FontSet，也就是 FcFontList 的结果的。\nfc-match 分析验证 双猫的Linux fontconfig 的字体匹配机制对 fc-match 已经有过一些分析了，比如 FcConfigSubstitute 是最重要的函数，但并不宏观。\nfc-match.c 一开始还是跟 fc-list.c 一样的，常规解析 pattern 和 objectset。\n然后是调用：\nFcConfigSubstitute (0, pat, FcMatchPattern); FcDefaultSubstitute (pat); fs = FcFontSetCreate (); 可以看到，它的 FontSet 是在最主要的函数执行过后才创建的，我们可以理解为是最终返回的那个新 FontSet。\n再往下是双猫说过的分别针对 sort/all 和什么都不给默认是 match 的处理，主要是调用 FcFontSort 和 FcFontMatch得到 font_pattern，然后通过 FcFontSetAdd 加入到 FontSet。唯一不同的是 FcFontSort 后调用了一次 FcFontRenderPrepare。\n再往下，我们发现 pat 被 FcPatternDestroy毁掉了！\n然后是针对得到的 FontSet 逐个的应用 FcPatternFilter：\nfont = FcPatternFilter (fs-\u003efonts[j], os); FcPatternFilter 函数里最重要的是：\ne = FcPatternObjectFindElt (p, object); if (!e) 而 FcPatternObjectFindElt 里最重要的函数是 FcPatternObjectPosition。\n这个 FcPatternObjectPosition 听名字也能知道它是查找属性的。:charset=0x2122 找不到，\nfc-match -s sans-serif :charset=0x2122 就会返回空了。\n以上验证阶段说明了我们前面关于 ObjectSet 的论断是正确的，只有显式的给，它才会用。同时也说明了，在 fontconfig 自己这边，charset minus 方法是尊重的。\n但是也引入了更多的问题，比如，fc-match 里面没有看到 FcFontList 函数，它的 FontSet 完全是根据 FcConfigSubstitute 的结果做的。那么系统上的字体是在 FcConfigSubstitute 的哪步加进来的呢？\n我们也看到了加了 ObjectSet 去匹配是返回空的，也就是说，我们的 FontSet 里面的字体确实是没有 charset=0x2122 这个字符的，charset minus 方法确实是成功的。FontSet 最早肯定是系统上安装的真实字体形成的，那么是哪步把这个 charset 删掉的呢？在缓存里？还是在字体属性里？而且这中间只经历了一次 FcConfigSubstitute，是不是可以说 FcConfigSubstitute 本身在进行 pattern match 的时候就也应用了 font match 的规则呢？\nChromium/Chrome 在 Linux 上查找字体的方式 这个是双猫的Linux fontconfig 的字体匹配机制缺少的 Chromium 代码部分。之前 V2EX 上有个 rant Chrome 把 FreeTyoe/Fontconfig 全集成进自己沙盒以及扣肉满天下简直毒瘤到爆表!，说得不完全对，至少在我要 debug 的问题上，我不需要知道 skia 究竟干了什么，我只需要知道 chromium 最终是怎么在 Linux 上查找 Fallback 字体的就可以了。于是，我找到了 ui/gfx/font_fallback_linux.cc，里面有一个最重要的 GetFallbackFont 函数，它有关 fontconfig 部分的代码是这样的：\n可以看到，它跟 fc-match 差不多，调用了 FcFontSort 后得到了 FontSet，然后再逐个的 FcPatternGetCharSet。\n按照我们前面的分析，如果 FcConfigSubstitute 得到的这个 FontSet 里是进行过 charset minus 的，那么 FcPatternGetCharSet 是 100% 尊重的，就不会出现之前的用 Noto Sans CJK SC 显示 TM 符号的情况。\n看来我们要继续分析 FcConfigSubstitute 函数了。\n未完待续。\n",
  "wordCount" : "577",
  "inLanguage": "en",
  "datePublished": "2022-11-25T12:13:29+08:00",
  "dateModified": "2022-11-25T12:13:29+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Marguerite Su: Golang/Ruby Programmer, openSUSE Member",
    "logo": {
      "@type": "ImageObject",
      "url": "https://marguerite.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://marguerite.github.io" accesskey="h" title="Marguerite Su: Golang/Ruby Programmer, openSUSE Member (Alt + H)">Marguerite Su: Golang/Ruby Programmer, openSUSE Member</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title">
      深入理解 Linux fontconfig 第一部分：有关工作流的假设
    </h1>
    <div class="post-meta"><span title='2022-11-25 12:13:29 +0800 CST'>November 25, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 <a href="https://marguerite.su/posts/fontconfig_%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91">fontconfig 几个常见的坑</a>，第二篇 <a href="https://marguerite.su/posts/color_emoji_in_opensuse">Color Emoji in openSUSE</a>。</p>
<p>偶然在网上看到 Alynx Zhou 的<a href="https://sh.alynx.one/posts/Fontconfig-NotoColorEmoji-Antialias/">Fontconfig 和 Noto Color Emoji 和抗锯齿</a>里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。</p>
<p>先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：<a href="https://github.com/marguerite/fonts-config">marguerite/fonts-config</a>。后来我又重写了 openSUSE 的 fonts-config, 在 <a href="https://github.com/marguerite/fonts-config-ng">marguerite/fonts-config-ng</a>。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。</p>
<p>但是呢，实际上这种方法在现实中不怎么灵。</p>
<pre><code>&lt;match target=&quot;scan&quot;&gt;
  &lt;test name=&quot;family&quot;&gt;
    &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
  &lt;/test&gt;
  &lt;edit name=&quot;charset&quot; mode=&quot;assign&quot;&gt;
    &lt;minus&gt;
      &lt;name&gt;charset&lt;/name&gt;
      &lt;charset&gt;
        &lt;int&gt;0x2122&lt;/int&gt;
      &lt;/charset&gt;
    &lt;/minus&gt;
  &lt;/edit&gt;
&lt;/match&gt;
</code></pre>
<p>大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset 的操作了，但是在 Chromium 浏览器中测试是这样的：</p>
<pre><code>  &lt;body&gt;
   &lt;p&gt;
     &lt;span style=&quot;font-family: sans-serif; font-size: 100pt&quot;&gt;™&lt;/span&gt;
     &lt;span style=&quot;font-family: sans-serif; font-size: 100pt&quot;&gt;你好&lt;/span&gt;
   &lt;/p&gt;
  &lt;/body&gt;
</code></pre>
<p><img loading="lazy" src="../../../../%e5%9b%be%e7%89%87/Screenshot_20221125_123349.png" alt=""  />
</p>
<p>那个 TM 码点依然使用 Noto Sans CJK SC 显示。纳尼！TM 不是已经被屏蔽了嘛？</p>
<h2 id="简单朴素但不一定对的-fontconfig-工作流假设">简单朴素但不一定对的 fontconfig 工作流假设<a hidden class="anchor" aria-hidden="true" href="#简单朴素但不一定对的-fontconfig-工作流假设">#</a></h2>
<p>以上 charset minus 的方法源于我（可能也是大多数人）的一个朴素假设：</p>
<p><strong>fontconfig 的工作流程是先取系统上安装的全部字体，生成一个无序列表，然后通过 pattern match 调整这个列表，最后使用 font match 调整最终列表中字体的属性，返回给调用它的程序使用</strong>。</p>
<p>换句话说，我们假设的是，程序调用 fontconfig 是调用一个完整的工作流，最终返回给程序的字体中没有这个被减掉的 charset。返回的字体可以是 fontconfig 的缓存，也可以是真实的字体但同时返回的字体 charset 属性中没有这个被减掉的 charset，导致程序通过通过 charset 匹配 text 的阶段会失败，从而不去使用这个字体去显示这个字符。</p>
<p>当然了，fontconfig 毕竟不是 fontforge 这样的字体编辑程序，真实的在硬盘上的字体文件里这个字符肯定还是存在的。也许是 fontconfig 在缓存 binary data 的时候就去掉了这个 charset，也许只是在字体属性中去掉了。</p>
<p>但很可惜，这个假设通过我的 debug 发现它，<strong>对也不对</strong>。对的地方是在 fontconfig 自己的 utilities 比如 fc-match, fc-list 里，它是对的。错的地方是在别的程序里，调用方式的不同导致这个工作流<strong>很可能</strong>被掐头去尾取中间了。也就是说别的程序可能只是使用了 fontconfig 的 pattern match 阶段，得到字体就万事大吉了。后面的 font match 阶段可能根本就没有用（这个存疑，目前还没有 debug 到这里）。</p>
<h2 id="可能是正确的获取字体的方式以-fc-list-为例">可能是正确的获取字体的方式（以 fc-list 为例）<a hidden class="anchor" aria-hidden="true" href="#可能是正确的获取字体的方式以-fc-list-为例">#</a></h2>
<p>我们前面文章已经说过了，测试 charset minus 方法是否成功的方式有一种是使用：</p>
<pre><code>fc-list &quot;Noto Sans CJK SC&quot; :charset=0x2122
</code></pre>
<p>而我还看到过一种方式，就是依云的<a href="https://blog.lilydjwg.me/2011/10/23/use-fontconfig-to-query-font.30393.html">
使用 fontconfig 进行字体查询</a>。</p>
<p>首先我复制了一份 <a href="https://github.com/freedesktop/fontconfig/blob/master/fc-list/fc-list.c">fc-list.c</a> 的代码（不到没有办法肯定不能 runtime 改系统的 fontconfig 啊），改了以下地方：</p>
<pre><code>+ printf(&quot;%d\n&quot;, i);
+ printf(&quot;%d\n&quot;, argc);
+ printf(&quot;%s\n&quot;, argv[1]);
+ printf(&quot;%s\n&quot;, argv[2]);
if (argv[i]) { 
  pat = FcNameParse ((FcChar8 *) argv[i]);
  if (!pat) {
    fprintf (stderr, _(&quot;Unable to parse the pattern\n&quot;));
    return 1;
  }
  while (argv[++i]) {
    if (!os) {
      os = FcObjectSetCreate ();
      FcObjectSetAdd (os, argv[i]);
    }
  }
}
</code></pre>
<p>首先我需要知道 fc-lsit 把我的 <code>Noto Sans CJK SC</code> 和 <code>:charset=0x2122</code> 都识别成什么了。结果是把字体名字识别成 pattern：</p>
<pre><code> pat = FcNameParse((FcChar8 *) argv[i]);
</code></pre>
<p>把  <code>:charset=0x2122</code> 识别成了（这里说以下这个冒号就是个语法糖，表示“全部字体”，相当于 <code>: charset=0x2122</code>，也可以有别的写法比如 <code>: family lang</code>）：</p>
<pre><code>os = FcObjectSetCreate();
</code></pre>
<p>然后后面的：</p>
<pre><code>fs = FcFontList (0, pat, os);
</code></pre>
<p>得到 FontSet。</p>
<p>FcFontList 会内部调用 <code>FcFontSetList (config, sets, nsets, p, os);</code>，这里的 config 是 <code>config = FcConfigReference (config);</code> 但很明显我们传给它的 config 是 0 所以没什么用。<code>sets</code> 和 <code>nsets</code>是 FcFontList 里定义的并传过来的，我们传过来的 <code>pattern</code> 和 <code>objectset</code> 在这里起到的是筛选的作用，如果 <code>sets-&gt;fonts[n]</code> 不满足 pattern，loop 就会 continue, 相当于是丢弃了这个 font。</p>
<p>这个 FcFontSetList 函数下次使用 <code>os</code> 是在 <code>if (!FcListAppend (&amp;table, s-&gt;fonts[f], os, lang))</code> (如果没有 os，FcFontSetList 在前面会创建一个空的 os)。这里的 <code>&amp;table</code> 是 <code>FcListHashTable</code>, 最终是通过 <code>FcFontSetAdd</code> 把 table 里的 font 加到 <code> ret = FcFontSetCreate();</code> 这个新建的 FontSet 中并返回这个新建的 ret，作为 FcFontList 返回的 FontSet。</p>
<p>所以这里 <code>FcListAppend</code> 的作用是通过 <code>objectsets</code> 和 <code>lang</code> 去判断这个字体可不可以加入到最终的 FontSet。后面再深入的代码我们就不继续看了。下面是结论：</p>
<p><strong>通过 <code>pattern</code> 和 <code>objectset</code> 一起得到的 FontSet 会得到应用了 charset minus 的结果。</strong></p>
<p>说人话就是<strong>显式地使用 <code>:charset=0x2122</code> 去要求 charset 就会得到精确的减除 charset 后的字体。</strong></p>
<p>那么隐含式的调用呢？我们来看依云的代码（我做了截取）：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>他这里的 os 相当于是新建的空 ObjectSet，所以他最终的 FontSet 里面包含了 &ldquo;Noto Sans CJK SC&rdquo;。下面的 <code>FcPatternGetCharSet</code> 取的是真实字体的 Charset，也包含了 TM 字符。这在 <code>FcCharSetHasChar</code> 也得到了验证。</p>
<p>换句话说，如果想要取得 fontconfig 的 font match 结果后的字体，这个程序要改为使用 <code>objectset</code>，即：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>以上对 fc-list.c 和依云的 demo 的分析验证了上面假设中最没有用一部分，即：<strong>真实的在硬盘上的字体文件里这个字符肯定还是存在的</strong>。同时也说明了另一个事情：<code>FcPatternGetCharset</code>获取字体 charsets 是严格依赖喂给它的 FontSet，也就是 <code>FcFontList</code> 的结果的。</p>
<h2 id="fc-match-分析验证">fc-match 分析验证<a hidden class="anchor" aria-hidden="true" href="#fc-match-分析验证">#</a></h2>
<p>双猫的<a href="https://catcat.cc/post/2020-10-31/">Linux fontconfig 的字体匹配机制</a>对 fc-match 已经有过一些分析了，比如 FcConfigSubstitute 是最重要的函数，但并不宏观。</p>
<p>fc-match.c 一开始还是跟 fc-list.c 一样的，常规解析 <code>pattern</code> 和 <code>objectset</code>。</p>
<p>然后是调用：</p>
<pre><code>FcConfigSubstitute (0, pat, FcMatchPattern);
FcDefaultSubstitute (pat);

fs = FcFontSetCreate ();
</code></pre>
<p>可以看到，它的 FontSet 是在最主要的函数执行过后才创建的，我们可以理解为是最终返回的那个新 FontSet。</p>
<p>再往下是双猫说过的分别针对 sort/all 和什么都不给默认是 match 的处理，主要是调用 <code>FcFontSort</code> 和 <code>FcFontMatch</code>得到 font_pattern，然后通过 <code>FcFontSetAdd</code> 加入到 FontSet。唯一不同的是 <code>FcFontSort</code> 后调用了一次 <code>FcFontRenderPrepare</code>。</p>
<p>再往下，我们发现 <code>pat</code> 被 <code>FcPatternDestroy</code>毁掉了！</p>
<p>然后是针对得到的 FontSet 逐个的应用 <code>FcPatternFilter</code>：</p>
<pre><code> font = FcPatternFilter (fs-&gt;fonts[j], os);
</code></pre>
<p><code>FcPatternFilter</code> 函数里最重要的是：</p>
<pre><code>e = FcPatternObjectFindElt (p, object);
if (!e)
</code></pre>
<p>而 FcPatternObjectFindElt 里最重要的函数是 <code>FcPatternObjectPosition</code>。</p>
<p>这个 <code>FcPatternObjectPosition</code> 听名字也能知道它是查找属性的。<code>:charset=0x2122</code> 找不到，</p>
<pre><code>fc-match -s sans-serif :charset=0x2122
</code></pre>
<p>就会返回空了。</p>
<p>以上验证阶段说明了我们前面关于 <code>ObjectSet</code> 的论断是正确的，只有显式的给，它才会用。同时也说明了，在 fontconfig 自己这边，charset minus 方法是尊重的。</p>
<p>但是也引入了更多的问题，比如，fc-match 里面没有看到 <code>FcFontList</code> 函数，它的 FontSet 完全是根据 <code>FcConfigSubstitute</code> 的结果做的。那么系统上的字体是在 FcConfigSubstitute 的哪步加进来的呢？</p>
<p>我们也看到了加了 <code>ObjectSet</code> 去匹配是返回空的，也就是说，我们的 FontSet 里面的字体确实是没有 <code>charset=0x2122</code> 这个字符的，charset minus 方法确实是成功的。FontSet 最早肯定是系统上安装的真实字体形成的，那么是哪步把这个 charset 删掉的呢？在缓存里？还是在字体属性里？而且这中间只经历了一次 <code>FcConfigSubstitute</code>，是不是可以说 <code>FcConfigSubstitute</code> 本身在进行 pattern match 的时候就也应用了 font match 的规则呢？</p>
<h2 id="chromiumchrome-在-linux-上查找字体的方式">Chromium/Chrome 在 Linux 上查找字体的方式<a hidden class="anchor" aria-hidden="true" href="#chromiumchrome-在-linux-上查找字体的方式">#</a></h2>
<p>这个是双猫的<a href="https://catcat.cc/post/2020-10-31/">Linux fontconfig 的字体匹配机制</a>缺少的 Chromium 代码部分。之前 V2EX 上有个 rant <a href="https://www.v2ex.com/t/853093">Chrome 把 FreeTyoe/Fontconfig 全集成进自己沙盒以及扣肉满天下简直毒瘤到爆表!</a>，说得不完全对，至少在我要 debug 的问题上，我不需要知道 skia 究竟干了什么，我只需要知道 chromium 最终是怎么在 Linux 上查找 Fallback 字体的就可以了。于是，我找到了 <a href="https://github.com/chromium/chromium/blob/main/ui/gfx/font_fallback_linux.cc">ui/gfx/font_fallback_linux.cc</a>，里面有一个最重要的 <code>GetFallbackFont</code> 函数，它有关 fontconfig 部分的代码是这样的：</p>
<!-- raw HTML omitted -->
<!-- raw HTML omitted -->
<p>可以看到，它跟 fc-match 差不多，调用了 <code>FcFontSort</code> 后得到了 FontSet，然后再逐个的 <code>FcPatternGetCharSet</code>。</p>
<p>按照我们前面的分析，如果 <code>FcConfigSubstitute</code> 得到的这个 FontSet 里是进行过 charset minus 的，那么 <code>FcPatternGetCharSet</code> 是 100% 尊重的，就不会出现之前的用 <code>Noto Sans CJK SC</code> 显示 TM 符号的情况。</p>
<p>看来我们要继续分析 <code>FcConfigSubstitute</code> 函数了。</p>
<p>未完待续。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer><script src="https://utteranc.es/client.js"
        repo="marguerite/marguerite.github.io"
        issue-term="title"
        label="blog"
        theme="github-light"
        crossorigin="anonymous"
        async>
</script>
</article>
    </main>
    
<footer class="footer">
    <span>&copy; 2022 <a href="https://marguerite.github.io">Marguerite Su: Golang/Ruby Programmer, openSUSE Member</a></span>
    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
