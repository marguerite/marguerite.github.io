<!DOCTYPE html>
<html lang="en" dir="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>深入理解 Linux fontconfig 第一部分 | Marguerite Su: Golang/Ruby Programmer, openSUSE Member</title>
<meta name="keywords" content="">
<meta name="description" content="这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。
偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。
先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。
但是呢，实际上这种方法在现实中不怎么灵。
&lt;match target=&quot;scan&quot;&gt;
  &lt;test name=&quot;family&quot;&gt;
    &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
  &lt;/test&gt;
  &lt;edit name=&quot;charset&quot; mode=&quot;assign&quot;&gt;
    &lt;minus&gt;
      &lt;name&gt;charset&lt;/name&gt;
      &lt;charset&gt;
        &lt;int&gt;0x2122&lt;/int&gt;
      &lt;/charset&gt;
    &lt;/minus&gt;
  &lt;/edit&gt;
&lt;/match&gt;

大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset leaf 的操作了，但是在 Chromium 浏览器中测试是这样的：">
<meta name="author" content="">
<link rel="canonical" href="https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.45e028aa8ce0961349adf411b013ee39406be2c0bc80d4ea3fc04555f7f4611a.css" integrity="sha256-ReAoqozglhNJrfQRsBPuOUBr4sC8gNTqP8BFVff0YRo=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://marguerite.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://marguerite.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://marguerite.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://marguerite.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://marguerite.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="en" href="https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
            }

            .list {
                background: var(--theme);
            }

            .list:not(.dark)::-webkit-scrollbar-track {
                background: 0 0;
            }

            .list:not(.dark)::-webkit-scrollbar-thumb {
                border-color: var(--theme);
            }
        }

    </style>
</noscript><meta property="og:url" content="https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/">
  <meta property="og:site_name" content="Marguerite Su: Golang/Ruby Programmer, openSUSE Member">
  <meta property="og:title" content="深入理解 Linux fontconfig 第一部分">
  <meta property="og:description" content="这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。
偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。
先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。
但是呢，实际上这种方法在现实中不怎么灵。
&lt;match target=&#34;scan&#34;&gt; &lt;test name=&#34;family&#34;&gt; &lt;string&gt;Noto Sans CJK SC&lt;/string&gt; &lt;/test&gt; &lt;edit name=&#34;charset&#34; mode=&#34;assign&#34;&gt; &lt;minus&gt; &lt;name&gt;charset&lt;/name&gt; &lt;charset&gt; &lt;int&gt;0x2122&lt;/int&gt; &lt;/charset&gt; &lt;/minus&gt; &lt;/edit&gt; &lt;/match&gt; 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset leaf 的操作了，但是在 Chromium 浏览器中测试是这样的：">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="posts">
    <meta property="article:published_time" content="2022-11-25T12:13:29+08:00">
    <meta property="article:modified_time" content="2022-11-25T12:13:29+08:00">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="深入理解 Linux fontconfig 第一部分">
<meta name="twitter:description" content="这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。
偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。
先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。
但是呢，实际上这种方法在现实中不怎么灵。
&lt;match target=&quot;scan&quot;&gt;
  &lt;test name=&quot;family&quot;&gt;
    &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
  &lt;/test&gt;
  &lt;edit name=&quot;charset&quot; mode=&quot;assign&quot;&gt;
    &lt;minus&gt;
      &lt;name&gt;charset&lt;/name&gt;
      &lt;charset&gt;
        &lt;int&gt;0x2122&lt;/int&gt;
      &lt;/charset&gt;
    &lt;/minus&gt;
  &lt;/edit&gt;
&lt;/match&gt;

大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset leaf 的操作了，但是在 Chromium 浏览器中测试是这样的：">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Posts",
      "item": "https://marguerite.github.io/posts/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "深入理解 Linux fontconfig 第一部分",
      "item": "https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "深入理解 Linux fontconfig 第一部分",
  "name": "深入理解 Linux fontconfig 第一部分",
  "description": "这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。\n偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。\n先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。\n但是呢，实际上这种方法在现实中不怎么灵。\n\u0026lt;match target=\u0026quot;scan\u0026quot;\u0026gt; \u0026lt;test name=\u0026quot;family\u0026quot;\u0026gt; \u0026lt;string\u0026gt;Noto Sans CJK SC\u0026lt;/string\u0026gt; \u0026lt;/test\u0026gt; \u0026lt;edit name=\u0026quot;charset\u0026quot; mode=\u0026quot;assign\u0026quot;\u0026gt; \u0026lt;minus\u0026gt; \u0026lt;name\u0026gt;charset\u0026lt;/name\u0026gt; \u0026lt;charset\u0026gt; \u0026lt;int\u0026gt;0x2122\u0026lt;/int\u0026gt; \u0026lt;/charset\u0026gt; \u0026lt;/minus\u0026gt; \u0026lt;/edit\u0026gt; \u0026lt;/match\u0026gt; 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset leaf 的操作了，但是在 Chromium 浏览器中测试是这样的：\n",
  "keywords": [
    
  ],
  "articleBody": "这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 fontconfig 几个常见的坑，第二篇 Color Emoji in openSUSE。\n偶然在网上看到 Alynx Zhou 的Fontconfig 和 Noto Color Emoji 和抗锯齿里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。\n先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：marguerite/fonts-config。后来我又重写了 openSUSE 的 fonts-config, 在 marguerite/fonts-config-ng。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。\n但是呢，实际上这种方法在现实中不怎么灵。\nNoto Sans CJK SC charset 0x2122 大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset leaf 的操作了，但是在 Chromium 浏览器中测试是这样的：\n™ 你好 那个 ™ 码点依然使用 Noto Sans CJK SC 显示。纳尼！™ 不是已经被屏蔽了嘛？\n注：charset 字符集，charset leaf 字符集中的一个点。fontconfig 上游是这么定义的。\n朴素的 fontconfig 工作流假设 以上 charset minus 的方法源于我（可能也是大多数人）的一个朴素假设：\nfontconfig 的工作流程是先扫描(scan match)系统上安装的全部字体，生成一个列表，然后通过 pattern match 调整这个列表，最后使用 font match 调整最终列表中字体的属性，返回给调用它的程序使用。\n换句话说，我们假设的是，程序调用 fontconfig 是调用一个完整的工作流，最终返回给程序的字体中没有这个被减掉的 charset leaf。返回的字体可以是 fontconfig 的缓存，也可以是真实的字体但同时返回的字体 charset 属性中没有这个被减掉的 charset leaf，导致程序通过通过 charset 匹配 text 的阶段会失败，从而不去使用这个字体去显示这个字符。\n当然了，fontconfig 毕竟不是 fontforge 这样的字体编辑程序，真实的在硬盘上的字体文件里这个字符肯定还是存在的。也许是 fontconfig 在缓存 binary data 的时候就去掉了这个 charset leaf，也许只是在字体属性中去掉了。\n我通过 debug 发现这个假设，对也不对。对的地方是在 fontconfig 自己的 utilities 比如 fc-match, fc-list 里，它是对的。错的地方是在别的程序里，调用方式的不同导致这个工作流可能被掐头去尾取中间了。也就是说别的程序可能只是使用了 fontconfig 的 pattern match 阶段，得到字体就万事大吉了。前面的 scan match、后面的 font match 可能根本就没有用。使用 fontconfig 的程序只要 FcConfigReference() 进行空白初始化，而不是 FcConfigReference(own_config) 传自有 config ，都会成功。即使程序实现自己的初始化函数（比如 Chromium），最终也会调用 FcConfigReference() 进行空白初始化。（因为没人会重新实现一份实质空白的 config）\n薛定谔的 FontSet 我们前面文章已经说过了，测试 charset minus 方法是否成功的方式有一种是使用：\nfc-list \"Noto Sans CJK SC\" :charset=0x2122 而我还看到过一种方式，就是依云的 使用 fontconfig 进行字体查询。\n首先我复制了一份 fc-list.c 的代码（不到万不得已肯定不能 runtime 改系统的 fontconfig 啊），改了以下地方：\nprintf(\"%d\\n\", i); printf(\"%d\\n\", argc); printf(\"%s\\n\", argv[1]); printf(\"%s\\n\", argv[2]); if (argv[i]) { pat = FcNameParse ((FcChar8 *) argv[i]); if (!pat) { fprintf (stderr, _(\"Unable to parse the pattern\\n\")); return 1; } while (argv[++i]) { if (!os) { os = FcObjectSetCreate (); FcObjectSetAdd (os, argv[i]); } } } 首先我需要知道 fc-lsit 把我的 Noto Sans CJK SC 和 :charset=0x2122 都识别成什么了。结果是把字体名字识别成 pattern：\npat = FcNameParse((FcChar8 *) argv[i]); 把 :charset=0x2122 识别成了（这里说以下这个冒号就是个语法糖，表示“全部字体”，相当于 : charset=0x2122，也可以有别的写法比如 : family lang）：\nos = FcObjectSetCreate(); 然后后面的：\nfs = FcFontList (0, pat, os); 得到 FontSet。\nFcFontList 会内部调用 FcFontSetList (config, sets, nsets, p, os);，这里的 config 是 config = FcConfigReference (config);, sets 和 nsets是 FcFontList 里定义的并传过来的，我们传过来的 pattern 和 objectset 在这里起到的是筛选的作用，如果 sets-\u003efonts[n] 不满足 pattern，loop 就会 continue, 相当于是丢弃了这个 font。\n而 FcFontSetList 使用 os 是在 if (!FcListAppend (\u0026table, s-\u003efonts[f], os, lang)) (如果没有 os，FcFontSetList 在前面会创建一个空的 os)。这里的 \u0026table 是 FcListHashTable, 最终是通过 FcFontSetAdd 把 table 里的 font 加到 ret = FcFontSetCreate(); 这个新建的 FontSet 中并返回这个新建的 ret，作为 FcFontList 返回的 FontSet。\n所以这里 FcListAppend 的作用是通过 objectset 和 lang 去判断这个字体可不可以加入到最终的 FontSet，最终是调用到了 FcPatternObjectFindElt，结果返回 0。经过一番 debug，发现是因为\ne = FcPatternObjectFindElt (font, FcObjectFromName (os-\u003eobjects[o])); if (e) FcObjectFromName 取不到值。这里的 os-\u003eobjects[o] 就是 :charset=0x2122，为什么会取不到值呢？\n阅读了一番代码发现，FcObjectFromName 是从名字变为 FcObject 也就是 int，它要的是 charset，family 这样的规范化 name，正常是不应该接受 :charset=0x2122 的 233，看来是作者少了一个检查，或者认为 FcPatternObjectFindElt 本身就是检查。又各种确认一番，原来是我这里写错了：\nfc-list \"Noto Sans CJK SC\" :charset=0x2122 应该是：\nfc-lsit \"Noto Sans CJK SC:charset=0x2122\" 或者说那里是没有空格的。看来 fontconfig 被称为 Linux 下字体配置的难度天花板不是没有理由的。\n那就只能重来了，这回是把：\nNoto Sans CJK SC:charset=0x2122 整个识别为 pat。接下来是 FcListPatternMatchAny (const FcPattern *p, const FcPattern *font)-\u003eFcListValueListMatchAny:\nif (FcConfigCompareValue (\u0026fnt-\u003evalue, FC_OP (FcOpListing, FcOpFlagIgnoreBlanks), \u0026pat-\u003evalue)) 最后因为 OP 是 FcOpListing，类型是 FcTypeCharSet，是调用了 FcCharSetIsSubset 解出来没有这个 charset leaf 的。\n这里需要注意的是 FcListPatternMatchAny 以后接受的参数都是指针，而真正用于比较的 *font 是来自 config：\nif (config-\u003efonts[FcSetSystem]) sets[nsets++] = config-\u003efonts[FcSetSystem]; if (config-\u003efonts[FcSetApplication]) sets[nsets++] = config-\u003efonts[FcSetApplication]; 也就是上面 config = FcConfigReference(0) ，对它的分析放在以后。\n下面是结论：\n通过 pattern 中包含 :charset=0x2122 得到的 FontSet 会是应用了 charset minus 的结果。\n说人话就是显式地使用 :charset=0x2122 就一定会精确地得到含有某个 charset leaf 的字体，即返回结果去掉了减除该 charset leaf 的字体。不显式使用 :charset=0x2122 返回 Noto Sans CJK SC 也符合 fc-list 的初衷，你不要 charset 只要 Noto Sans CJK SC 肯定会给你返回它。\n那么隐式的调用呢？我们来看依云的代码：\nFcFontSet* fs = NULL; FcPattern* pat = NULL; FcObjectSet* os = NULL; FcChar8* strpat = (FcChar8*)\":lang=zh\"; pat = FcNameParse(strpat); os = FcObjectSetBuild(FC_FAMILY, FC_CHARSET, FC_FILE, (char *)0); fs = FcFontList(0, pat, os); 他这里的 pattern 是 :lang=zh，意思是取全部 lang=zh 的字体，所以他最终的 FontSet 里面包含了 “Noto Sans CJK SC”。接着 FcPatternGetCharSet 取 Charset，却包含了 ™ 字符：\nif(FcPatternGetCharSet(fs-\u003efonts[i], FC_CHARSET, 0, \u0026cs) != FcResultMatch){ 这就有点不对了啊。因为我们如果显式去使用 :charset=0x2122，是对 FontSet 进行修改，如果 FontSet 里的 Noto Sans CJK SC含有这个 charset leaf肯定不会去掉它的。但隐式地先取到 FontSet，再去调用 FcPatternGetCharset，得到的结果确是 FontSet 里含有这个 charset leaf。\nFcResult FcPatternGetCharSet(const FcPattern *p, const char *object, int id, FcCharSet **c) { FcValue\tv; FcResult\tr; r = FcPatternGet (p, object, id, \u0026v); if (r != FcResultMatch) return r; if (v.type != FcTypeCharSet) return FcResultTypeMismatch; *c = (FcCharSet *)v.u.c; return FcResultMatch; } 同时，FcPatternGetCharset 是一个 get 函数，是不会修改 FontSet 的。\n这个留着后续研究了。暂时只能说隐式调用不行 行，方法在后续。\nfc-match 分析 双猫的Linux fontconfig 的字体匹配机制对 fc-match 已经有过一些分析了，比如 FcConfigSubstitute 是最重要的函数。\nfc-match.c 一开始还是跟 fc-list.c 一样的，常规解析 pattern 和 objectset。\n然后是调用：\nFcConfigSubstitute (0, pat, FcMatchPattern); FcDefaultSubstitute (pat); fs = FcFontSetCreate (); 再往下是双猫说过的分别针对 sort/all 和默认 match 的处理，主要是调用 FcFontSort 和 FcFontMatch得到 font_pattern，然后通过 FcFontSetAdd 加入到 FontSet。\n然后是针对得到的 FontSet 逐个的应用 FcPatternFilter过滤 os，这样最后就会只输出某个属性比如 family。\n对它的分析引入了更多的问题，比如，fc-match 里面没有看到 FcFontList 函数，它的 FontSet 完全是根据 FcConfigSubstitute 的结果做的。那么系统上的字体是在 FcConfigSubstitute 的哪步加进来的呢？\n我们也知道加了 :charset=0x2122 去匹配是返回空的：\n$ fc-match -s \"sans-serif:charset=0x2122\" 也就是说，我们得到的 FontSet 里面的字体应该是没有 charset=0x2122 这个字符的。FontSet 肯定是系统上安装的真实字体形成的，那么 FcConfigSubsitute 是怎么把这个 charset leaf 删掉的呢？在缓存时？还是 MatchAny 的时候？而且这中间只经历了一次 FcConfigSubstitute，是不是可以说 FcConfigSubstitute 本身在进行 pattern match 的时候就也应用了 scan match 和 font match 的规则呢？\nChromium/Chrome 在 Linux 上查找字体的方式 这个是双猫的Linux fontconfig 的字体匹配机制缺少的 Chromium 代码部分。之前 V2EX 上有个 rant Chrome 把 FreeTyoe/Fontconfig 全集成进自己沙盒以及扣肉满天下简直毒瘤到爆表!，说得不完全对，至少在我要 debug 的问题上，我不需要知道 skia 究竟干了什么，我只需要知道 chromium 最终是怎么在 Linux 上查找 Fallback 字体的就可以了。于是，我找到了 ui/gfx/font_fallback_linux.cc，里面有一个最重要的 GetFallbackFont 函数，它有关 fontconfig 部分的代码是这样的：\n找错了位置，找到 UI 字体的 Fallback 去了，而不是 blink 引擎处理网页中文字的字体 Fallback 逻辑。但为了引出第二篇要分析的 FcConfigSubstitute，姑且保留。另外，3年后才发现，太需要知道 skia 究竟干了什么了…原谅我当年的无知…\nFcConfig* config = GetGlobalFontConfig(); FcConfigSubstitute(config, pattern.get(), FcMatchPattern); FcDefaultSubstitute(pattern.get()); FallbackFontEntries fallback_font_entries; FcResult fc_result; FcFontSet* fonts = FcFontSort(config, pattern.get(), FcTrue, nullptr, \u0026fc_result); if (fonts) { // Add each potential fallback font returned by font-config to the // set of fallback fonts and keep track of their codepoints coverage. for (int i = 0; i \u003c fonts-\u003enfont; ++i) { FcPattern* current_font = fonts-\u003efonts[i]; if (!IsValidFontFromPattern(current_font)) continue; // Retrieve the font identity fields. base::FilePath font_path = GetFontPath(current_font); int font_ttc_index = GetFontTtcIndex(current_font); // Retrieve the charset of the current font. FcCharSet* char_set = nullptr; fc_result = FcPatternGetCharSet(current_font, FC_CHARSET, 0, \u0026char_set); if (fc_result != FcResultMatch || char_set == nullptr) continue; // Retrieve the font render params. FontRenderParams font_params; GetFontRenderParamsFromFcPattern(current_font, \u0026font_params); fallback_font_entries.push_back(FallbackFontEntry( font_path, font_ttc_index, font_params, char_set)); } FcFontSetDestroy(fonts); } 可以看到，它跟 fc-match 差不多，调用了 FcFontSort 后得到了 FontSet，然后再逐个的 FcPatternGetCharSet。\n按照我们前面的分析，如果 FcConfigSubstitute 得到的这个 FontSet 里是进行过 charset minus 的，那么 FcPatternGetCharSet 是 100% 尊重的，就不会出现之前的用 Noto Sans CJK SC 显示 ™ 符号的情况。\n看来我们要继续分析 FcConfigSubstitute 的实现了。\n",
  "wordCount" : "896",
  "inLanguage": "en",
  "datePublished": "2022-11-25T12:13:29+08:00",
  "dateModified": "2022-11-25T12:13:29+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://marguerite.github.io/posts/getting_to_know_fontconfig_part_one/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Marguerite Su: Golang/Ruby Programmer, openSUSE Member",
    "logo": {
      "@type": "ImageObject",
      "url": "https://marguerite.github.io/favicon.ico"
    }
  }
}
</script>
</head>

<body class="" id="top">
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.body.classList.add('dark');
    } else if (localStorage.getItem("pref-theme") === "light") {
        document.body.classList.remove('dark')
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.body.classList.add('dark');
    }

</script>

<header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://marguerite.github.io/" accesskey="h" title="Marguerite Su: Golang/Ruby Programmer, openSUSE Member (Alt + H)">Marguerite Su: Golang/Ruby Programmer, openSUSE Member</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
            </div>
        </div>
        <ul id="menu">
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      深入理解 Linux fontconfig 第一部分
    </h1>
    <div class="post-meta"><span title='2022-11-25 12:13:29 +0800 CST'>November 25, 2022</span>

</div>
  </header> 
  <div class="post-content"><p>这篇文章是之前两篇关于 fontconfig 文章的后续，前文见第一篇 <a href="https://marguerite.su/posts/fontconfig_%E5%87%A0%E4%B8%AA%E5%B8%B8%E8%A7%81%E7%9A%84%E5%9D%91">fontconfig 几个常见的坑</a>，第二篇 <a href="https://marguerite.su/posts/color_emoji_in_opensuse">Color Emoji in openSUSE</a>。</p>
<p>偶然在网上看到 Alynx Zhou 的<a href="https://sh.alynx.one/posts/Fontconfig-NotoColorEmoji-Antialias/">Fontconfig 和 Noto Color Emoji 和抗锯齿</a>里面说看过我的文，没想到我对 fontconfig 的研究在中文圈还是排在前头的 ⌣。原来大家对后续还是有期待的。</p>
<p>先说一下我 2020 年写完那两篇文章干什么去了。我在 Color Emoji in openSUSE 里面不是提到过几个 .rb 代码文件嘛，有些人说找不到它们，其实它们在我的 fork 里面：<a href="https://github.com/marguerite/fonts-config">marguerite/fonts-config</a>。后来我又重写了 openSUSE 的 fonts-config, 在 <a href="https://github.com/marguerite/fonts-config-ng">marguerite/fonts-config-ng</a>。可以自动生成 Emoji Glyph 的 Blacklist，也就是 81_emoji_blacklist_glyphs.conf。</p>
<p>但是呢，实际上这种方法在现实中不怎么灵。</p>
<pre><code>&lt;match target=&quot;scan&quot;&gt;
  &lt;test name=&quot;family&quot;&gt;
    &lt;string&gt;Noto Sans CJK SC&lt;/string&gt;
  &lt;/test&gt;
  &lt;edit name=&quot;charset&quot; mode=&quot;assign&quot;&gt;
    &lt;minus&gt;
      &lt;name&gt;charset&lt;/name&gt;
      &lt;charset&gt;
        &lt;int&gt;0x2122&lt;/int&gt;
      &lt;/charset&gt;
    &lt;/minus&gt;
  &lt;/edit&gt;
&lt;/match&gt;
</code></pre>
<p>大家可以看到我在 81_emoji_blacklist_glyphs.conf 里面已经有从 Noto Sans CJK SC 字体减除 0x2122（™）这个 charset leaf 的操作了，但是在 Chromium 浏览器中测试是这样的：</p>
<pre><code>  &lt;body&gt;
   &lt;p&gt;
     &lt;span style=&quot;font-family: sans-serif; font-size: 100pt&quot;&gt;™&lt;/span&gt;
     &lt;span style=&quot;font-family: sans-serif; font-size: 100pt&quot;&gt;你好&lt;/span&gt;
   &lt;/p&gt;
  &lt;/body&gt;
</code></pre>
<p><img loading="lazy" src="../../images/Screenshot_20221125_123349.png"></p>
<p>那个 ™ 码点依然使用 Noto Sans CJK SC 显示。纳尼！™ 不是已经被屏蔽了嘛？</p>
<p>注：charset 字符集，charset leaf 字符集中的一个点。fontconfig 上游是这么定义的。</p>
<h2 id="朴素的-fontconfig-工作流假设">朴素的 fontconfig 工作流假设<a hidden class="anchor" aria-hidden="true" href="#朴素的-fontconfig-工作流假设">#</a></h2>
<p>以上 charset minus 的方法源于我（可能也是大多数人）的一个朴素假设：</p>
<p><strong>fontconfig 的工作流程是先扫描(<code>scan match</code>)系统上安装的全部字体，生成一个列表，然后通过 pattern match 调整这个列表，最后使用 font match 调整最终列表中字体的属性，返回给调用它的程序使用</strong>。</p>
<p>换句话说，我们假设的是，程序调用 fontconfig 是调用一个完整的工作流，最终返回给程序的字体中没有这个被减掉的 charset leaf。返回的字体可以是 fontconfig 的缓存，也可以是真实的字体但同时返回的字体 charset 属性中没有这个被减掉的 charset leaf，导致程序通过通过 charset 匹配 text 的阶段会失败，从而不去使用这个字体去显示这个字符。</p>
<p>当然了，fontconfig 毕竟不是 fontforge 这样的字体编辑程序，真实的在硬盘上的字体文件里这个字符肯定还是存在的。也许是 fontconfig 在缓存 binary data 的时候就去掉了这个 charset leaf，也许只是在字体属性中去掉了。</p>
<p>我通过 debug 发现这个假设，<strong>对<del>也不对</del></strong>。对的地方是在 fontconfig 自己的 utilities 比如 fc-match, fc-list 里，它是对的。<del>错的地方是在别的程序里，调用方式的不同导致这个工作流<strong>可能</strong>被掐头去尾取中间了。也就是说别的程序可能只是使用了 fontconfig 的 pattern match 阶段，得到字体就万事大吉了。前面的 scan match、后面的 font match 可能根本就没有用。</del><strong>使用 fontconfig 的程序只要 FcConfigReference() 进行空白初始化，而不是 FcConfigReference(own_config) 传自有 config ，都会成功。即使程序实现自己的初始化函数（比如 Chromium），最终也会调用 FcConfigReference()  进行空白初始化。（因为没人会重新实现一份实质空白的 config）</strong></p>
<h2 id="薛定谔的-fontset">薛定谔的 FontSet<a hidden class="anchor" aria-hidden="true" href="#薛定谔的-fontset">#</a></h2>
<p>我们前面文章已经说过了，测试 charset minus 方法是否成功的方式有一种是使用：</p>
<pre><code>fc-list &quot;Noto Sans CJK SC&quot; :charset=0x2122
</code></pre>
<p>而我还看到过一种方式，就是依云的<a href="https://blog.lilydjwg.me/2011/10/23/use-fontconfig-to-query-font.30393.html">
使用 fontconfig 进行字体查询</a>。</p>
<p>首先我复制了一份 <a href="https://github.com/freedesktop/fontconfig/blob/master/fc-list/fc-list.c">fc-list.c</a> 的代码（不到万不得已肯定不能 runtime 改系统的 fontconfig 啊），改了以下地方：</p>
<pre><code>printf(&quot;%d\n&quot;, i);
printf(&quot;%d\n&quot;, argc);
printf(&quot;%s\n&quot;, argv[1]);
printf(&quot;%s\n&quot;, argv[2]);
if (argv[i]) { 
  pat = FcNameParse ((FcChar8 *) argv[i]);
  if (!pat) {
    fprintf (stderr, _(&quot;Unable to parse the pattern\n&quot;));
    return 1;
  }
  while (argv[++i]) {
    if (!os) {
      os = FcObjectSetCreate ();
      FcObjectSetAdd (os, argv[i]);
    }
  }
}
</code></pre>
<p>首先我需要知道 fc-lsit 把我的 <code>Noto Sans CJK SC</code> 和 <code>:charset=0x2122</code> 都识别成什么了。结果是把字体名字识别成 pattern：</p>
<pre><code> pat = FcNameParse((FcChar8 *) argv[i]);
</code></pre>
<p>把  <code>:charset=0x2122</code> 识别成了（这里说以下这个冒号就是个语法糖，表示“全部字体”，相当于 <code>: charset=0x2122</code>，也可以有别的写法比如 <code>: family lang</code>）：</p>
<pre><code>os = FcObjectSetCreate();
</code></pre>
<p>然后后面的：</p>
<pre><code>fs = FcFontList (0, pat, os);
</code></pre>
<p>得到 FontSet。</p>
<p>FcFontList 会内部调用 <code>FcFontSetList (config, sets, nsets, p, os);</code>，这里的 config 是 <code>config = FcConfigReference (config);</code>, <code>sets</code> 和 <code>nsets</code>是 FcFontList 里定义的并传过来的，我们传过来的 <code>pattern</code> 和 <code>objectset</code> 在这里起到的是筛选的作用，如果 <code>sets-&gt;fonts[n]</code> 不满足 pattern，loop 就会 continue, 相当于是丢弃了这个 font。</p>
<p>而 <code>FcFontSetList</code> 使用 <code>os</code> 是在 <code>if (!FcListAppend (&amp;table, s-&gt;fonts[f], os, lang))</code> (如果没有 os，FcFontSetList 在前面会创建一个空的 os)。这里的 <code>&amp;table</code> 是 <code>FcListHashTable</code>, 最终是通过 <code>FcFontSetAdd</code> 把 table 里的 font 加到 <code> ret = FcFontSetCreate();</code> 这个新建的 FontSet 中并返回这个新建的 ret，作为 FcFontList 返回的 FontSet。</p>
<p>所以这里 <code>FcListAppend</code> 的作用是通过 <code>objectset</code> 和 <code>lang</code> 去判断这个字体可不可以加入到最终的 FontSet，最终是调用到了 <code>FcPatternObjectFindElt</code>，结果返回 0。经过一番 debug，发现是因为</p>
<pre><code>e = FcPatternObjectFindElt (font, FcObjectFromName (os-&gt;objects[o]));
if (e)
</code></pre>
<p>FcObjectFromName 取不到值。这里的 <code>os-&gt;objects[o]</code> 就是 <code>:charset=0x2122</code>，为什么会取不到值呢？</p>
<p>阅读了一番代码发现，<code>FcObjectFromName</code> 是从名字变为 FcObject 也就是 int，它要的是 <code>charset</code>，<code>family</code> 这样的规范化 name，正常是不应该接受 <code>:charset=0x2122</code> 的 233，看来是作者少了一个检查，或者认为 <code>FcPatternObjectFindElt</code> 本身就是检查。又各种确认一番，原来是我这里写错了：</p>
<pre><code>fc-list &quot;Noto Sans CJK SC&quot; :charset=0x2122
</code></pre>
<p>应该是：</p>
<pre><code>fc-lsit &quot;Noto Sans CJK SC:charset=0x2122&quot;
</code></pre>
<p>或者说那里是没有空格的。看来 fontconfig 被称为 Linux 下字体配置的难度天花板不是没有理由的。</p>
<p>那就只能重来了，这回是把：</p>
<pre><code>Noto Sans CJK SC:charset=0x2122
</code></pre>
<p>整个识别为 pat。接下来是 <code>FcListPatternMatchAny (const FcPattern *p, const FcPattern *font)</code>-&gt;<code>FcListValueListMatchAny</code>:</p>
<pre><code>if (FcConfigCompareValue (&amp;fnt-&gt;value,
	  FC_OP (FcOpListing, FcOpFlagIgnoreBlanks),
	  &amp;pat-&gt;value))
</code></pre>
<p>最后因为 OP 是 <code>FcOpListing</code>，类型是 <code>FcTypeCharSet</code>，是调用了 <code>FcCharSetIsSubset</code> 解出来没有这个 charset leaf 的。</p>
<p>这里需要注意的是 <code>FcListPatternMatchAny</code> 以后接受的参数都是指针，而真正用于比较的 <code>*font</code> 是来自 config：</p>
<pre><code>if (config-&gt;fonts[FcSetSystem])
   sets[nsets++] = config-&gt;fonts[FcSetSystem];
if (config-&gt;fonts[FcSetApplication])
   sets[nsets++] = config-&gt;fonts[FcSetApplication];
</code></pre>
<p>也就是上面 <code>config = FcConfigReference(0)</code> ，对它的分析放在以后。</p>
<p>下面是结论：</p>
<p><strong>通过 <code>pattern</code> 中包含 <code>:charset=0x2122</code> 得到的 FontSet 会是应用了 charset minus 的结果。</strong></p>
<p>说人话就是<strong>显式地使用 <code>:charset=0x2122</code> 就一定会精确地得到含有某个 charset leaf 的字体，即返回结果去掉了减除该 charset leaf 的字体</strong>。不显式使用 <code>:charset=0x2122</code> 返回 <code>Noto Sans CJK SC</code> 也符合 <code>fc-list</code> 的初衷，你不要 charset 只要 Noto Sans CJK SC 肯定会给你返回它。</p>
<p>那么隐式的调用呢？我们来看依云的代码：</p>
<pre><code>  FcFontSet* fs = NULL;
  FcPattern* pat = NULL;
  FcObjectSet* os = NULL;

  FcChar8* strpat = (FcChar8*)&quot;:lang=zh&quot;;
  pat = FcNameParse(strpat);
  os = FcObjectSetBuild(FC_FAMILY, FC_CHARSET, FC_FILE, (char *)0);
  fs = FcFontList(0, pat, os);
</code></pre>
<p>他这里的 <code>pattern</code> 是 <code>:lang=zh</code>，意思是取全部 <code>lang=zh</code> 的字体，所以他最终的 FontSet 里面包含了 &ldquo;Noto Sans CJK SC&rdquo;。接着 <code>FcPatternGetCharSet</code> 取 Charset，却包含了 ™ 字符：</p>
<pre><code>if(FcPatternGetCharSet(fs-&gt;fonts[i], FC_CHARSET, 0, &amp;cs) != FcResultMatch){
</code></pre>
<p>这就有点不对了啊。因为我们如果显式去使用 <code>:charset=0x2122</code>，是对 FontSet 进行修改，如果 FontSet 里的 <code>Noto Sans CJK SC</code>含有这个 charset leaf肯定不会去掉它的。但隐式地先取到 FontSet，再去调用 <code>FcPatternGetCharset</code>，得到的结果确是 FontSet 里含有这个 charset leaf。</p>
<pre><code>FcResult
FcPatternGetCharSet(const FcPattern *p, const char *object, int id, FcCharSet **c) {
  FcValue	v;
  FcResult	r;

  r = FcPatternGet (p, object, id, &amp;v);
  if (r != FcResultMatch)
    return r;
  if (v.type != FcTypeCharSet)
    return FcResultTypeMismatch;
  *c = (FcCharSet *)v.u.c;
  return FcResultMatch;
}
</code></pre>
<p>同时，<code>FcPatternGetCharset</code> 是一个 get 函数，是不会修改 FontSet 的。</p>
<p><del>这个留着后续研究了。暂时只能说隐式调用不行</del> <strong>行，方法在后续</strong>。</p>
<h2 id="fc-match-分析">fc-match 分析<a hidden class="anchor" aria-hidden="true" href="#fc-match-分析">#</a></h2>
<p>双猫的<a href="https://catcat.cc/post/2020-10-31/">Linux fontconfig 的字体匹配机制</a>对 fc-match 已经有过一些分析了，比如 FcConfigSubstitute 是最重要的函数。</p>
<p>fc-match.c 一开始还是跟 fc-list.c 一样的，常规解析 <code>pattern</code> 和 <code>objectset</code>。</p>
<p>然后是调用：</p>
<pre><code>FcConfigSubstitute (0, pat, FcMatchPattern);
FcDefaultSubstitute (pat);

fs = FcFontSetCreate ();
</code></pre>
<p>再往下是双猫说过的分别针对 sort/all 和默认 match 的处理，主要是调用 <code>FcFontSort</code> 和 <code>FcFontMatch</code>得到 font_pattern，然后通过 <code>FcFontSetAdd</code> 加入到 FontSet。</p>
<p>然后是针对得到的 FontSet 逐个的应用 <code>FcPatternFilter</code>过滤 <code>os</code>，这样最后就会只输出某个属性比如 <code>family</code>。</p>
<p>对它的分析引入了更多的问题，比如，fc-match 里面没有看到 <code>FcFontList</code> 函数，它的 FontSet 完全是根据 <code>FcConfigSubstitute</code> 的结果做的。那么系统上的字体是在 FcConfigSubstitute 的哪步加进来的呢？</p>
<p>我们也知道加了 <code>:charset=0x2122</code> 去匹配是返回空的：</p>
<pre><code>$ fc-match -s &quot;sans-serif:charset=0x2122&quot;
</code></pre>
<p>也就是说，我们得到的 FontSet 里面的字体应该是没有 <code>charset=0x2122</code> 这个字符的。FontSet 肯定是系统上安装的真实字体形成的，那么 <code>FcConfigSubsitute</code> 是怎么把这个 charset leaf 删掉的呢？在缓存时？还是 <code>MatchAny</code> 的时候？而且这中间只经历了一次 <code>FcConfigSubstitute</code>，是不是可以说 <code>FcConfigSubstitute</code> 本身在进行 pattern match 的时候就也应用了 scan match 和 font match 的规则呢？</p>
<h2 id="chromiumchrome-在-linux-上查找字体的方式">Chromium/Chrome 在 Linux 上查找字体的方式<a hidden class="anchor" aria-hidden="true" href="#chromiumchrome-在-linux-上查找字体的方式">#</a></h2>
<p><del>这个是双猫的<a href="https://catcat.cc/post/2020-10-31/">Linux fontconfig 的字体匹配机制</a>缺少的 Chromium 代码部分。之前 V2EX 上有个 rant <a href="https://www.v2ex.com/t/853093">Chrome 把 FreeTyoe/Fontconfig 全集成进自己沙盒以及扣肉满天下简直毒瘤到爆表!</a>，说得不完全对，至少在我要 debug 的问题上，我不需要知道 skia 究竟干了什么，我只需要知道 chromium 最终是怎么在 Linux 上查找 Fallback 字体的就可以了。于是，我找到了 <a href="https://github.com/chromium/chromium/blob/main/ui/gfx/font_fallback_linux.cc">ui/gfx/font_fallback_linux.cc</a>，里面有一个最重要的 <code>GetFallbackFont</code> 函数，它有关 fontconfig 部分的代码是这样的：</del></p>
<p><strong>找错了位置，找到 UI 字体的 Fallback 去了，而不是 blink 引擎处理网页中文字的字体 Fallback 逻辑。但为了引出第二篇要分析的 FcConfigSubstitute，姑且保留。另外，3年后才发现，太需要知道 skia 究竟干了什么了&hellip;原谅我当年的无知&hellip;</strong></p>
<pre><code>FcConfig* config = GetGlobalFontConfig();
FcConfigSubstitute(config, pattern.get(), FcMatchPattern);
FcDefaultSubstitute(pattern.get());
FallbackFontEntries fallback_font_entries;
FcResult fc_result;
FcFontSet* fonts = FcFontSort(config, pattern.get(), FcTrue, nullptr, &amp;fc_result);
if (fonts) {
  // Add each potential fallback font returned by font-config to the
  // set of fallback fonts and keep track of their codepoints coverage.
  for (int i = 0; i &lt; fonts-&gt;nfont; ++i) {
    FcPattern* current_font = fonts-&gt;fonts[i];
    if (!IsValidFontFromPattern(current_font))
      continue;

    // Retrieve the font identity fields.
    base::FilePath font_path = GetFontPath(current_font);
    int font_ttc_index = GetFontTtcIndex(current_font);

    // Retrieve the charset of the current font.
    FcCharSet* char_set = nullptr;
    fc_result = FcPatternGetCharSet(current_font, FC_CHARSET, 0, &amp;char_set);
    if (fc_result != FcResultMatch || char_set == nullptr)
      continue;

    // Retrieve the font render params.
    FontRenderParams font_params;
    GetFontRenderParamsFromFcPattern(current_font, &amp;font_params);

    fallback_font_entries.push_back(FallbackFontEntry(
        font_path, font_ttc_index, font_params, char_set));
  }
  FcFontSetDestroy(fonts);
}
</code></pre>
<p>可以看到，它跟 fc-match 差不多，调用了 <code>FcFontSort</code> 后得到了 FontSet，然后再逐个的 <code>FcPatternGetCharSet</code>。</p>
<p>按照我们前面的分析，如果 <code>FcConfigSubstitute</code> 得到的这个 FontSet 里是进行过 charset minus 的，那么 <code>FcPatternGetCharSet</code> 是 100% 尊重的，就不会出现之前的用 <code>Noto Sans CJK SC</code> 显示 ™ 符号的情况。</p>
<p>看来我们要继续分析 <code>FcConfigSubstitute</code> 的实现了。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2025 <a href="https://marguerite.github.io/">Marguerite Su: Golang/Ruby Programmer, openSUSE Member</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu')
    if (menu) {
        menu.scrollLeft = localStorage.getItem("menu-scroll-position");
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        if (document.body.className.includes("dark")) {
            document.body.classList.remove('dark');
            localStorage.setItem("pref-theme", 'light');
        } else {
            document.body.classList.add('dark');
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
